# Webアプリケーションのパフォーマンス原因特定：フェーズ別分析法

おっしゃる通り、パフォーマンスの問題は明確なフェーズに分けて分析すると原因特定が容易になります。Angularアプリケーションのライフサイクルも考慮して、以下のように体系的に分類できます。

## 1. 初期読み込みフェーズ (TTFB〜HTML解析)

**何が起きる？**
- DNSルックアップ、TCP接続、TLSハンドシェイク
- サーバーからの初期レスポンス取得
- HTMLの解析

**遅延の原因：**
- サーバーサイドの処理遅延（SQLクエリ、バックエンド処理）
- ネットワークレイテンシ
- サーバー設定の問題

**調査方法：**
- Edge開発者ツールの「Network」タブでTTFB (Time To First Byte)を確認
- Waitingの時間が長い → バックエンド処理の問題
- Receivingの時間が長い → ネットワーク速度の問題

## 2. リソース読み込みフェーズ (アセット取得)

**何が起きる？**
- CSS、JavaScript、画像、フォントなどの読み込み
- Angularのメインバンドルとチャンクのダウンロード

**遅延の原因：**
- バンドルサイズが過大
- リソース数が多すぎる
- リソースの最適化不足（圧縮なし、キャッシュなし）

**調査方法：**
- 「Network」タブで大きなファイルやリクエスト数を確認
- Waterfallでブロッキングリソースを特定
- Angularのバンドルアナライザでバンドルサイズを分析

## 3. DOM構築フェーズ (レンダリング準備)

**何が起きる？**
- DOMツリーの構築
- CSSOMの構築
- レンダーツリーの作成

**遅延の原因：**
- 複雑すぎるDOM構造
- 巨大なCSSファイル
- CSSセレクタの非効率

**調査方法：**
- 「Performance」タブで「Parse HTML」や「Recalculate Style」の時間を確認
- DOMノード数の確認（Elements > Console で `document.querySelectorAll('*').length`）

## 4. Angular初期化フェーズ

**何が起きる？**
- Angularアプリケーションのブートストラップ
- ルートモジュールの初期化
- コンポーネントツリーの構築

**遅延の原因：**
- 過剰なプロバイダーやサービスの初期化
- 重いNgModuleの初期化処理
- AOTコンパイルの未使用

**調査方法：**
- 「Performance」タブで「Evaluate Script」を確認（Angularの初期化コード）
- Angularのデバッグツールで初期化時間を測定

## 5. データ取得フェーズ (API通信)

**何が起きる？**
- コンポーネントのngOnInitなどでのAPI呼び出し
- リゾルバーによるデータのプリロード
- HTTPリクエストの実行と応答待ち

**遅延の原因：**
- APIエンドポイントのレスポンス遅延（SQLクエリの問題など）
- ネットワーク遅延
- 不必要に多いAPIコール
- ウォーターフォール型の依存APIコール

**調査方法：**
- 「Network」タブでXHRやFetchリクエストを確認
- APIレスポンスタイムの確認
- バックエンドログでSQLクエリの実行時間を確認

## 6. レンダリングフェーズ

**何が起きる？**
- Angularの変更検知（Change Detection）
- DOMの更新
- ブラウザによるレイアウト計算とペイント

**遅延の原因：**
- 非効率な変更検知戦略
- 重いコンポーネントロジック
- 複雑なテンプレート式
- 多数のDOM更新

**調査方法：**
- 「Performance」タブで「Layout」「Paint」「Composite」の時間を確認
- Angularプロファイラーを使用（`ng.profiler.timeChangeDetection()`）

## 7. インタラクションフェーズ

**何が起きる？**
- ユーザー操作に対するイベントハンドリング
- 変更検知の実行
- 画面の再レンダリング

**遅延の原因：**
- 長時間実行されるイベントハンドラ
- 過剰な再レンダリング
- 非効率なDOMアクセス

**調査方法：**
- 「Performance」タブでインタラクション後のメインスレッド活動を記録
- イベントリスナーの処理時間確認

## 8. メモリ管理フェーズ

**何が起きる？**
- オブジェクトの作成と破棄
- ガベージコレクション
- メモリリーク

**遅延の原因：**
- 頻繁なガベージコレクション
- メモリリーク（購読解除忘れなど）
- 大きすぎるステート

**調査方法：**
- 「Memory」タブでヒープスナップショットを取得
- メモリ使用量の経時変化を確認

## 実践的な原因特定フロー

1. **全体像を把握**：Lighthouseで基本スコアをチェック

2. **段階的な絞り込み**：
   - TTFB高い → バックエンド/ネットワーク問題
   - DOMContentLoaded遅い → HTML解析/リソース読み込み問題
   - FCP遅い → レンダリング問題
   - LCP遅い → 重要コンテンツの読み込み/レンダリング問題
   - INP高い → イベントハンドリング/変更検知の問題

3. **Angular固有の問題検出**：
   - 変更検知の頻度確認（DevToolsのタイムライン上の頻繁なレンダリング）
   - サービス初期化のボトルネック特定
   - 遅延ロードモジュールの最適化
   - Observableのメモリリークチェック

この体系的なアプローチで、「HTML描画の問題」「APIネットワーク遅延」「SQLパフォーマンス問題」などを段階的に切り分けることができます。特にAngularアプリケーションでは、変更検知のサイクルとコンポーネントライフサイクルフックの理解が重要です。
