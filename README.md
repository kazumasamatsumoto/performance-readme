# ブラウザでできるWebアプリの速さチェック：簡単ガイド

## 主な3つの指標を理解する

### 1. LCP（最大コンテンツの表示時間）
- **これは何？** ページの一番大きな要素（画像やテキストブロックなど）が表示されるまでの時間
- **なぜ重要？** ユーザーが「このサイト、読み込み速いな」と感じるかどうかの目安
- **目標値：** 2.5秒以下が良い

### 2. INP（操作から画面更新までの時間）
- **これは何？** ボタンをクリックしてから反応があるまでの時間
- **なぜ重要？** ユーザーが「このサイト、サクサク動くな」と感じるかどうかの目安
- **目標値：** 200ミリ秒以下が良い

### 3. CLS（レイアウトの安定性）
- **これは何？** ページ読み込み中に要素が勝手に動いてしまう度合い
- **なぜ重要？** ユーザーが「読もうとしたらボタンが移動して間違えて押しちゃった」といったストレスを感じないため
- **目標値：** 0.1以下が良い

## Edgeブラウザでの簡単な調べ方

### 基本の手順
1. **開発者ツールを開く：** F12キーを押す
2. **Lighthouseタブを使う：** 
   - 「Lighthouse」タブをクリック
   - 「Performance」にチェックを入れる
   - 「Analyze」ボタンを押す
   - 結果が表示されたら「Core Web Vitals」の部分を確認

### 各指標の詳しい調べ方

#### LCPを調べる
1. 「Performance」タブに移動
2. 「記録」ボタン（丸い赤いボタン）をクリック
3. ページをリロード
4. 記録が終わったら、上部のタイムラインで「LCP」というマーカーを探す
5. LCPの要素をクリックすると、何が遅い原因かわかる

#### INPを調べる
1. 「Performance」タブで記録を開始
2. ボタンをクリックするなど実際に操作してみる
3. 記録を停止
4. タイムラインで操作した時間帯を確認
5. 長い棒グラフがあれば、それが遅延の原因

#### CLSを調べる
1. 「Performance」タブで記録
2. ページが完全に読み込まれるまで待つ
3. 「Experience」セクションを探し、「Layout Shift」を確認
4. 赤い部分をクリックすると、どの要素が動いたかわかる

## 問題の具体的な探し方

### サイトが全体的に遅い場合
- **ネットワークタブで確認：** 大きすぎるファイルはないか
- **特に注目：** 画像サイズ、JavaScript/CSSファイルの数と大きさ

### クリックの反応が遅い場合
- **Performance記録で確認：** クリック後のJavaScript実行時間
- **特に注目：** 長いタスク（赤い部分）を探す

### 画面がガタガタ動く場合
- **画像サイズ指定を確認：** width/heightが指定されていないと後から動く
- **フォントの読み込みを確認：** フォントが後から読み込まれると文字幅が変わる

簡単な改善のコツ：
- 画像は適切なサイズに圧縮する
- 必要ないJavaScriptは読み込まない
- 画像やフォントのサイズを事前に指定する
- 重い処理は分割して実行する

何か具体的に確認したい部分はありますか？

# Webアプリケーションのパフォーマンス原因特定：フェーズ別分析法

おっしゃる通り、パフォーマンスの問題は明確なフェーズに分けて分析すると原因特定が容易になります。Angularアプリケーションのライフサイクルも考慮して、以下のように体系的に分類できます。

## 1. 初期読み込みフェーズ (TTFB〜HTML解析)

**何が起きる？**
- DNSルックアップ、TCP接続、TLSハンドシェイク
- サーバーからの初期レスポンス取得
- HTMLの解析

**遅延の原因：**
- サーバーサイドの処理遅延（SQLクエリ、バックエンド処理）
- ネットワークレイテンシ
- サーバー設定の問題

**調査方法：**
- Edge開発者ツールの「Network」タブでTTFB (Time To First Byte)を確認
- Waitingの時間が長い → バックエンド処理の問題
- Receivingの時間が長い → ネットワーク速度の問題

## 2. リソース読み込みフェーズ (アセット取得)

**何が起きる？**
- CSS、JavaScript、画像、フォントなどの読み込み
- Angularのメインバンドルとチャンクのダウンロード

**遅延の原因：**
- バンドルサイズが過大
- リソース数が多すぎる
- リソースの最適化不足（圧縮なし、キャッシュなし）

**調査方法：**
- 「Network」タブで大きなファイルやリクエスト数を確認
- Waterfallでブロッキングリソースを特定
- Angularのバンドルアナライザでバンドルサイズを分析

## 3. DOM構築フェーズ (レンダリング準備)

**何が起きる？**
- DOMツリーの構築
- CSSOMの構築
- レンダーツリーの作成

**遅延の原因：**
- 複雑すぎるDOM構造
- 巨大なCSSファイル
- CSSセレクタの非効率

**調査方法：**
- 「Performance」タブで「Parse HTML」や「Recalculate Style」の時間を確認
- DOMノード数の確認（Elements > Console で `document.querySelectorAll('*').length`）

## 4. Angular初期化フェーズ

**何が起きる？**
- Angularアプリケーションのブートストラップ
- ルートモジュールの初期化
- コンポーネントツリーの構築

**遅延の原因：**
- 過剰なプロバイダーやサービスの初期化
- 重いNgModuleの初期化処理
- AOTコンパイルの未使用

**調査方法：**
- 「Performance」タブで「Evaluate Script」を確認（Angularの初期化コード）
- Angularのデバッグツールで初期化時間を測定

## 5. データ取得フェーズ (API通信)

**何が起きる？**
- コンポーネントのngOnInitなどでのAPI呼び出し
- リゾルバーによるデータのプリロード
- HTTPリクエストの実行と応答待ち

**遅延の原因：**
- APIエンドポイントのレスポンス遅延（SQLクエリの問題など）
- ネットワーク遅延
- 不必要に多いAPIコール
- ウォーターフォール型の依存APIコール

**調査方法：**
- 「Network」タブでXHRやFetchリクエストを確認
- APIレスポンスタイムの確認
- バックエンドログでSQLクエリの実行時間を確認

## 6. レンダリングフェーズ

**何が起きる？**
- Angularの変更検知（Change Detection）
- DOMの更新
- ブラウザによるレイアウト計算とペイント

**遅延の原因：**
- 非効率な変更検知戦略
- 重いコンポーネントロジック
- 複雑なテンプレート式
- 多数のDOM更新

**調査方法：**
- 「Performance」タブで「Layout」「Paint」「Composite」の時間を確認
- Angularプロファイラーを使用（`ng.profiler.timeChangeDetection()`）

## 7. インタラクションフェーズ

**何が起きる？**
- ユーザー操作に対するイベントハンドリング
- 変更検知の実行
- 画面の再レンダリング

**遅延の原因：**
- 長時間実行されるイベントハンドラ
- 過剰な再レンダリング
- 非効率なDOMアクセス

**調査方法：**
- 「Performance」タブでインタラクション後のメインスレッド活動を記録
- イベントリスナーの処理時間確認

## 8. メモリ管理フェーズ

**何が起きる？**
- オブジェクトの作成と破棄
- ガベージコレクション
- メモリリーク

**遅延の原因：**
- 頻繁なガベージコレクション
- メモリリーク（購読解除忘れなど）
- 大きすぎるステート

**調査方法：**
- 「Memory」タブでヒープスナップショットを取得
- メモリ使用量の経時変化を確認

## 実践的な原因特定フロー

1. **全体像を把握**：Lighthouseで基本スコアをチェック

2. **段階的な絞り込み**：
   - TTFB高い → バックエンド/ネットワーク問題
   - DOMContentLoaded遅い → HTML解析/リソース読み込み問題
   - FCP遅い → レンダリング問題
   - LCP遅い → 重要コンテンツの読み込み/レンダリング問題
   - INP高い → イベントハンドリング/変更検知の問題

3. **Angular固有の問題検出**：
   - 変更検知の頻度確認（DevToolsのタイムライン上の頻繁なレンダリング）
   - サービス初期化のボトルネック特定
   - 遅延ロードモジュールの最適化
   - Observableのメモリリークチェック

この体系的なアプローチで、「HTML描画の問題」「APIネットワーク遅延」「SQLパフォーマンス問題」などを段階的に切り分けることができます。特にAngularアプリケーションでは、変更検知のサイクルとコンポーネントライフサイクルフックの理解が重要です。
